![image](https://user-images.githubusercontent.com/71887536/184316595-2eb2ffdc-7b10-4b56-9df0-0fb4e3f59718.png)

![image](https://user-images.githubusercontent.com/71887536/184316648-1107a3d7-3b2b-4fc5-a806-88b71d5de37e.png)


# The Stack
Follows a Last In, First Out (LIFO) flow. `esp`/`rsp` holds the address in memory where the bottom of the stack is. When something is `push`ed onto the stack, the stack point (`esp`) is decremented by 4 bytes on an x86 system. On x64 that value would be 8 bytes. When a `pop` instruction is executed, the value at `esp` is retrieved (`esp` is dereferenced), and `esp` is then incremented by 4 (x86) or 8 bytes (x64).

## Uses of the stack
- Storing arguments
- Storing local variables
- Storing processor state between function calls

# The Heap
This is a place in memory which a program can use to dynamically create objects. This allows for dynamic sized allocations and persistent allocation when a function is returned. Some disadvantages are that allocations on the heap can be slower and heap allocations must be manually cleaned up.

- `malloc` allocates a specified number of bytes onto the heap
- `free` will free the given heap allocation


# x64 Arguments
- 1st: `rdi`
- 2nd: `rsi`
- 3rd: `rdx`
- 4th: `rcx`
- 5th: `r8`
- 6th: `r9`
- After the 6th argument, you'll need to allocate space on the stack and push them in reverse order.


# Global Offset Table (GOT)
The GOT is a section inside of programs that holds addresses of functions that are dynamically linked. Most programs don't include every function they use to reduce binary size. Instead, common functions (like those in libc) are "linked" into the program so they can be saved once on disk and reused by every program. All dynamic libraries are loaded into memory along with the main program at launch, however functions are not mapped to their actual code until they're first called.

- The GOT containers pointers to libraries which will move due to ASLR
- The GOT is a writable area

# Procedure Linkage Table (PLT)
Before a functions address has been resolved, the GOT points to an entry in the PLT. This is a small "stub" function which is responsible for calling the dynamic linker with (effectively) the name of the function that should be resolved.

# Return Oriented Programming (ROP)
This is the idea of chaining together pieces of assembly with stack control to cause the program to do more complex things. Having stack control is powerful since it allows you to overwrite saved instruction pointers, which in turn gives you control of what the program does next.

# Binary Protections:

## Position Independent Executable (PIE)
This means that every time you run the file it gets loaded into a different memory address, therefore you cannot hardcode values such as function addresses and gadget locations without finding where they are.

## No eXecute (NX):
This is also known as Data Execution Prevention which marks the stack as non-executable. You can visualize this easily in a program like [gdb](https://www.sourceware.org/gdb/) w/[GEF](https://github.com/hugsy/gef) or [radare2](https://rada.re/n/).
- gdb w/GEF command: `vmmap`
- radare2 command: `dm`

## Address Space Layout Randomisation (ASLR)
Every time you run a binary, libraries get loaded into different memory addresses. ASLR is a kernel protection while PIE is a binary protection.
## Differences Between ASLR and PIE
**PIE** is compiled into the binary  
**ASLR** is dependant on the environment running the binary

## Relocation Read-Only (RELRO)
### Partial RELRO
- Forces the GOT to come before the BSS in memory, eliminating the risk of buffer overflows on a global variable overwriting GOT entries

### Full RELRO
- Makes the entire GOT read-only which removes the ability to perform a "GOT overwrite" attack
- Not a default complier setting as it can increase program startup time since all symbols must be resolved before the program is started

## Stack Canaries
At the beginning of the function, a random value is placed on the stack. Before the program executes `ret`, the current value of that variable is compared to the initial: if they are the same, no buffer overflow has occurred. If they are not, the attacker attempted to overflow the return pointer and the program exits. This can often present a message `***stack smashing detected***`.

---
Sources: https://ctf101.org/binary-exploitation/overview/, https://ir0nstone.gitbook.io/notes/, https://ctf101.org/binary-exploitation/relocation-read-only/
